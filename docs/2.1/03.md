# microtask（Promise） vs nextTick

## Node.js 中真正的“插队规则”

---

## 一、先给结论（必须背下来）

> **process.nextTick 的优先级 > Promise microtask 的优先级**
>
> 并且：
> **nextTick / microtask 都不属于 event loop 的任何阶段**

它们是：

> **每个阶段结束时，都会被“强制清空”的插队队列**

---

## 二、Node.js 中的真实执行模型（非常关键）

### 1️⃣ Node 的一次“执行节奏”长这样

```text
执行同步代码
↓
清空 nextTick 队列（全部）
↓
清空 Promise microtask 队列（全部）
↓
进入 event loop 的某个阶段（timers / poll / check…）
↓
阶段回调执行完
↓
清空 nextTick
↓
清空 Promise microtask
↓
进入下一个阶段
```

👉 **注意两个“清空”：**

* 不是执行一个
* 是 **全部执行完**

---

## 三、nextTick 队列：Node 的“最高优先级插队”

### 1️⃣ nextTick 的本质

```js
process.nextTick(fn)
```

> **在当前 JS 调用栈结束后立即执行**
> **不让事件循环推进一步**

---

### 2️⃣ 一个最基础但必须会的例子

```js
console.log('A')

process.nextTick(() => console.log('B'))

Promise.resolve().then(() => console.log('C'))

console.log('D')
```

输出顺序：

```text
A
D
B
C
```

原因：

* 同步：A → D
* nextTick 先清空
* Promise 后清空

---

### 3️⃣ nextTick 的危险性（为什么会饿死 IO）

```js
function loop() {
  process.nextTick(loop)
}
loop()
```

发生了什么？

```text
同步栈清空
↓
nextTick 队列有任务 → 执行
↓
又塞一个 nextTick
↓
永远清空不完
↓
event loop 永远进不去
```

👉 **IO、timers、setImmediate 全部饿死**

---

### 4️⃣ 工程级结论

> **nextTick 是“同步代码的延伸”，不是异步**

---

## 四、Promise microtask：标准的“微任务队列”

### 1️⃣ Promise.then 的位置

```js
Promise.resolve().then(fn)
```

> **在当前阶段结束后、进入下一阶段前执行**

---

### 2️⃣ Promise 不会阻止事件循环“阶段推进”

```js
function loop() {
  Promise.resolve().then(loop)
}
loop()
```

结果：

* CPU 很高
* 但 **event loop 还能推进**
* timers / IO 有机会执行

👉 **比 nextTick “温和”**

---

### 3️⃣ 但 Promise 依然可能“饿死 IO”

```js
async function loop() {
  while (true) {
    await Promise.resolve()
  }
}
loop()
```

原因：

* 每一轮 poll 结束
* microtask 队列又被塞满
* poll 等 IO 的时间被压缩

👉 **不是死锁，是“慢性窒息”**

---

## 五、nextTick vs Promise 的本质差异

| 维度       | process.nextTick | Promise.then |
| -------- | ---------------- | ------------ |
| 是否标准     | ❌ Node 私有        | ✅ ECMAScript |
| 优先级      | **最高**           | 次高           |
| 是否阻塞阶段推进 | ✅                | ❌            |
| 饿死 IO 风险 | 极高               | 中            |
| 适合业务使用   | ❌                | ⚠️           |

---

## 六、为什么 Node 要设计 nextTick？

> **为了“修复同步 API 的一致性”**

典型用途：

* 在同步函数里补发异步回调
* 保证用户回调“异步化”

```js
function readConfig(cb) {
  if (cache) {
    process.nextTick(cb)
  } else {
    fs.readFile(file, cb)
  }
}
```

👉 **这是 nextTick 的正当用途**

---

## 七、Node 服务端的“微任务铁律”（非常重要）

### ❌ 绝对禁止

* 业务逻辑使用 nextTick
* nextTick 递归 / 循环
* 在 nextTick 里跑重逻辑

---

### ⚠️ 谨慎使用

* Promise.then 大量递归
* async/await 写无限微任务

---

### ✅ 推荐

* IO 并发：Promise.all
* IO 后调度：setImmediate
* 延迟任务：setTimeout
* 框架修复：nextTick（极少）

---

## 八、一个“解释 90% 线上问题”的顺序口诀

> **nextTick 永远插在最前面**
> **Promise 紧跟其后不进站**
> **阶段执行完才轮到 IO**
> **插队太多，系统就喘不过气**

---

## 九、终极执行顺序示意（可直接贴文档）

```text
同步代码
↓
process.nextTick（全部）
↓
Promise.then / await（全部）
↓
event loop 阶段（timers → poll → check…）
↓
process.nextTick
↓
Promise.then
↓
下一阶段
```

---

## 十、一句话总结（非常适合写在章节结尾）

> **nextTick 是 Node 的“手术刀”
> Promise 是语言的“微调器”
> 用错 nextTick，你的服务会“看起来不忙，却什么都不干”**

---
