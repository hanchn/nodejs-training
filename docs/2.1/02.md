# setTimeout vs setImmediate vs process.nextTick

## Node.js 执行差异与真实语义

---

## 一、一句话先给“终极结论”

> **process.nextTick = 插队到当前阶段结束前**
> **Promise.then = 插队到下一个阶段前**
> **setImmediate = IO 回调后立刻执行**
> **setTimeout = 至少延迟到下一轮 timers**

---

## 二、它们在事件循环里的“官方位置”

```text
同步代码
↓
process.nextTick        （最高优先级，独立队列）
↓
Promise.then            （microtask）
↓
timers                  （setTimeout / setInterval）
↓
poll                    （IO 回调）
↓
check                   （setImmediate）
↓
close callbacks
```

⚠️ **nextTick / Promise 不属于任何阶段，是“插队机制”**

---

## 三、process.nextTick（最危险，也最容易被误用）

### 1️⃣ 它到底干了什么？

```js
process.nextTick(fn)
```

> **在当前调用栈清空后，立刻执行 fn**
> **不等事件循环进入下一阶段**

---

### 2️⃣ nextTick 的真实语义

* 不进入 event loop
* 每个阶段结束都会清空 nextTick 队列
* **优先级高于 Promise**

---

### 3️⃣ 典型事故代码（线上真实）

```js
function loop() {
  process.nextTick(loop)
}
loop()
```

结果：

```text
事件循环被饿死
IO 永远得不到执行
```

👉 CPU 不一定满，但服务完全卡死

---

### 4️⃣ 正确使用场景（极少）

| 场景       | 合理 |
| -------- | -- |
| 修复同步 API | ✅  |
| 内部状态调整   | ✅  |
| 业务调度     | ❌  |

> **nextTick 是给 Node 内部用的，不是给业务写的**

---

## 四、setTimeout（最常被误解）

### 1️⃣ setTimeout 并不“准时”

```js
setTimeout(fn, 0)
```

真实含义：

> **fn 最早会在下一轮 timers 阶段执行**

并不保证：

* 下一行执行
* 比 setImmediate 快

---

### 2️⃣ setTimeout 的两个关键限制

1️⃣ 必须等：

* 当前执行栈
* 当前 microtask
* 当前 poll

2️⃣ 受事件循环状态影响

---

### 3️⃣ setTimeout(0) 的典型误判

```js
setTimeout(() => console.log('timeout'), 0)
setImmediate(() => console.log('immediate'))
```

输出：

```text
不确定（取决于环境）
```

👉 **顶层脚本里顺序不稳定**

---

### 4️⃣ 工程定位

* 业务延迟
* retry / backoff
* 定时任务

❌ 不用于：

* 精准调度
* IO 后立即执行

---

## 五、setImmediate（被严重低估）

### 1️⃣ setImmediate 的唯一承诺

> **在 poll 阶段结束后，立即执行**

```js
setImmediate(fn)
```

---

### 2️⃣ IO 场景下的确定顺序（重点）

```js
fs.readFile('a.txt', () => {
  setTimeout(() => console.log('timeout'), 0)
  setImmediate(() => console.log('immediate'))
})
```

输出永远是：

```text
immediate
timeout
```

👉 **这是 Node 保证的**

---

### 3️⃣ setImmediate 的工程价值

| 场景               | 是否推荐 |
| ---------------- | ---- |
| IO 回调后调度         | ✅    |
| 拆解长任务            | ✅    |
| 替代 setTimeout(0) | ✅    |
| 精准延时             | ❌    |

---

## 六、三者的对比表（工程版）

| 维度              | nextTick | setImmediate | setTimeout |
| --------------- | -------- | ------------ | ---------- |
| 是否进入 event loop | ❌        | ✅            | ✅          |
| 执行阶段            | 当前阶段结束前  | check        | timers     |
| 优先级             | 最高       | 中            | 低          |
| IO 后顺序          | 最先       | 第二           | 最后         |
| 滥用风险            | 极高       | 低            | 中          |

---

## 七、你在 Node 服务端该怎么选？

### ✅ 选型指南

* **修复同步 API →** `process.nextTick`
* **IO 回调后立刻执行 →** `setImmediate`
* **业务延迟 / 重试 →** `setTimeout`
* **绝不用于业务调度 →** `nextTick`

---

## 八、一个“能解释 90% 问题”的口诀

> **nextTick 插队不进场**
> **Promise 排在下一站**
> **Immediate 紧跟 IO 后**
> **Timeout 至少下一轮**

---

## 九、为什么这在“线上特别重要”？

因为：

* 滥用 nextTick → 事件循环饿死
* 用错 setTimeout → 延迟放大
* 不懂 setImmediate → IO 调度不稳定

👉 **这些不是“性能优化”，而是“能不能活”的问题**

---

## 十、给你一个“服务端铁律总结”

### ❌ 禁止

* while + nextTick
* 用 setTimeout(0) 模拟异步
* 在 nextTick 里跑逻辑

### ✅ 推荐

* IO 后调度用 setImmediate
* 延迟任务用 setTimeout
* nextTick 只用于框架内部

---
