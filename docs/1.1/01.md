# JavaScript 核心语义（Node.js 视角）

## 作用域与闭包 · 原型链 · this · class · 模块化

> **Node.js 不是浏览器 JS**
> 在服务端，这些语义直接影响：**并发安全、内存、可维护性、线上稳定性**

---

## 一、作用域与闭包（Node 内存与并发的根）

### 1️⃣ 作用域的本质

JS 只有三种作用域：

* 全局作用域
* 函数作用域
* 块级作用域（`let / const`）

**Node 中特别重要的一点：**

> ❗ **一个进程 = 一个全局作用域**

---

### 2️⃣ 闭包是什么（不是定义，是后果）

```js
function createCounter() {
  let count = 0
  return () => ++count
}

const counter = createCounter()
```

闭包 ≠ 技巧
闭包 = **变量生命周期被拉长**

---

### 3️⃣ Node 里闭包的真实风险

#### ❌ 常见线上坑：内存泄漏

```js
const cache = {}

app.get('/api', (req, res) => {
  cache[req.id] = req   // ❌ 请求对象被闭包引用
})
```

**问题本质**

* 请求结束了
* 闭包还活着
* GC 无法回收

---

### 4️⃣ Node 的原则性结论

* ❌ 不要在闭包里存 request / response
* ❌ 不要把“请求态数据”放在模块级变量
* ✅ 闭包只适合：

  * 纯配置
  * 常量
  * 短生命周期逻辑

---

## 二、原型链（Node 面向对象与性能）

### 1️⃣ 原型链不是“继承”，是**查找路径**

```js
obj.prop
```

查找顺序：

```text
obj
↓
obj.__proto__
↓
obj.__proto__.__proto__
↓
null
```

---

### 2️⃣ Node 中为什么要关心原型链？

#### ❌ 滥用原型会影响性能

```js
Array.prototype.foo = function () {}
```

* 污染全局
* 影响所有数组
* 可能导致 V8 失去优化机会

---

### 3️⃣ 服务端的正确姿势

* ❌ 不改内置原型（Array/Object/String）
* ✅ 用组合，不用魔改继承
* ✅ 原型方法只放**无状态逻辑**

---

## 三、this（Node 最容易误判的点）

### 1️⃣ this 从来不“指向定义位置”

> **this 只跟“怎么调用”有关**

---

### 2️⃣ Node 常见 this 误区

```js
class Service {
  getData() {
    return this.repo.find()
  }
}

const { getData } = new Service()
getData() // ❌ this = undefined
```

---

### 3️⃣ Node 场景中的 this 规则速记

| 调用方式           | this            |
| -------------- | --------------- |
| 普通函数           | undefined（严格模式） |
| obj.fn()       | obj             |
| class 方法       | 调用者             |
| arrow function | 继承外层 this       |

---

### 4️⃣ 工程建议（非常重要）

* ❌ Node 中避免在核心逻辑里依赖 this
* ✅ 用显式参数
* ✅ 或在 constructor 中 bind

```js
this.getData = this.getData.bind(this)
```

---

## 四、class（Node 里的 class ≠ Java）

### 1️⃣ class 只是语法糖

```js
class A {}
```

等价于：

```js
function A() {}
A.prototype = {}
```

---

### 2️⃣ Node 服务中 class 的合理定位

**class 适合：**

* Service
* Repository
* Client 封装
* 无状态 / 轻状态对象

**class 不适合：**

* 存请求状态
* 承载大量 mutable 数据

---

### 3️⃣ class + Node 的隐藏坑

#### ❌ 把请求态塞进实例

```js
class UserService {
  constructor(req) {
    this.req = req // ❌
  }
}
```

👉 **多请求并发时，状态极易串**

---

### 4️⃣ 正确模式（函数式优先）

```js
class UserService {
  getUser(id) {}
}

// 调用时传参
service.getUser(userId)
```

---

## 五、模块化语义（Node 最容易被低估的一点）

### 1️⃣ Node 的模块 ≠ 文件

> **Node 模块是“单例”**

```js
// a.js
module.exports = { count: 0 }

// b.js
const a = require('./a')
a.count++
```

所有 `require('./a')`：

* 拿到的是**同一个对象**

---

### 2️⃣ Node 模块缓存机制（关键）

* 第一次 require → 执行模块
* 之后 require → 直接返回缓存

---

### 3️⃣ 线上高危写法

```js
// config.js
module.exports = {
  currentUser: null
}
```

👉 **这是全局共享状态**

---

### 4️⃣ 模块化的正确心智模型

| 放在模块级 | 放在函数里     |
| ----- | --------- |
| 常量    | 请求态数据     |
| 配置    | req / res |
| 客户端实例 | 用户状态      |
| 连接池   | 临时变量      |

---

### 5️⃣ CommonJS vs ESM（Node 语义差异）

| 维度      | CommonJS | ESM  |
| ------- | -------- | ---- |
| 加载      | 运行时      | 编译期  |
| 是否缓存    | 是        | 是    |
| 导出      | 值拷贝      | 引用绑定 |
| Node 生态 | 成熟       | 新标准  |

**服务端建议**

* 老项目：CommonJS
* 新项目：ESM + 明确边界

---

## 六、这一章的“服务端黄金总结”

> **Node.js 中：**

* 闭包决定内存
* 原型链决定性能
* this 决定 Bug
* class 决定结构
* 模块化决定并发安全

---

## 七、给你一张“是否危险”的快速判断表

| 场景           | 是否危险  |
| ------------ | ----- |
| 模块级变量存请求数据   | ❌ 极危险 |
| 闭包引用 req/res | ❌     |
| class 持有请求状态 | ❌     |
| 改内置原型        | ❌     |
| 模块只导出纯函数     | ✅     |
| 模块只放配置/常量    | ✅     |

---
