# Node.js 常见坑位（必踩但要提前避）

## 循环引用 · 浅拷贝 / 深拷贝 · 浮点数 · BigInt

> **这些坑不是“会不会写 JS”的问题**
> 而是：**一旦踩到，线上一定会炸**

---

## 一、循环引用（Node 最隐蔽的线上炸点）

### 1️⃣ 什么是循环引用（不是“互相 require”这么简单）

#### 模块级循环引用

```js
// a.js
const b = require('./b')
module.exports = { fromB: b.value }

// b.js
const a = require('./a')
module.exports = { value: 1 }
```

Node 行为：

* a.js 执行到一半
* b.js require a.js → 拿到 **未执行完的 exports**
* 得到 **undefined / 半成品对象**

👉 **不会报错，但逻辑是错的**

---

### 2️⃣ 更危险的：对象级循环引用

```js
const a = {}
const b = { a }
a.b = b
```

#### 线上后果

* `JSON.stringify` 直接抛异常
* 日志、埋点、缓存序列化失败
* SSR 渲染 crash

---

### 3️⃣ Node 服务端的铁律

❌ 禁止：

* 模块互相 require
* request / response 挂到全局对象
* 配置对象互相引用

✅ 建议：

* 抽公共依赖到第三模块
* 明确单向依赖
* 序列化前做结构校验

---

## 二、浅拷贝 vs 深拷贝（并发安全杀手）

### 1️⃣ 99% 的 Node Bug 都出在这里

```js
const baseConfig = {
  headers: { token: '' }
}

function handleRequest(req) {
  const config = { ...baseConfig }
  config.headers.token = req.token
}
```

**你以为是安全的，实际上：**

* headers 是共享引用
* 多请求并发时串数据

---

### 2️⃣ 浅拷贝的本质

```text
拷贝一层
↓
引用还在
```

包括：

* Object.assign
* 展开运算符 `{ ...obj }`
* Array.slice

---

### 3️⃣ 深拷贝不是“随便来一个”

#### ❌ 错误认知

```js
JSON.parse(JSON.stringify(obj))
```

问题：

* 丢 Date / undefined / function
* 爆内存
* 循环引用直接崩

---

### 4️⃣ Node 服务端正确姿势

| 场景    | 建议                        |
| ----- | ------------------------- |
| 配置对象  | 冻结（Object.freeze）         |
| 请求态数据 | 新对象构建                     |
| 复杂结构  | structuredClone（Node 17+） |
| 高性能   | 手动控制拷贝边界                  |

---

## 三、浮点数（钱、库存、统计一定会踩）

### 1️⃣ 经典坑（你一定见过）

```js
0.1 + 0.2 === 0.3 // false
```

👉 **不是 JS 的 bug，是 IEEE 754**

---

### 2️⃣ Node 服务端的真实风险

* 金额计算
* 汇率
* 折扣
* 统计数据

```js
price * 100 * discount / 100
```

👉 **误差会被放大**

---

### 3️⃣ 服务端铁律

❌ 禁止：

* 用浮点数算钱
* 用浮点数做等值判断

✅ 正确方式：

* 统一用 **整数最小单位**

  * 金额 → 分
  * 百分比 → basis point
* 或使用 decimal 库

---

### 4️⃣ 一个实用原则

> **浮点数只用于展示，不用于计算**

---

## 四、BigInt（新坑，比你想象得危险）

### 1️⃣ BigInt 是什么

```js
const id = 12345678901234567890n
```

* 能表示超大整数
* JS number 不行

---

### 2️⃣ Node 服务端 BigInt 的坑

#### ❌ 1. BigInt 不能 JSON.stringify

```js
JSON.stringify({ id: 1n })
// TypeError
```

👉 日志、接口直接炸

---

#### ❌ 2. BigInt 和 Number 不能混算

```js
1n + 1 // ❌
```

---

#### ❌ 3. 前后端协议不兼容

* 前端 JSON
* 后端 BigInt
* 中间层直接失败

---

### 3️⃣ Node 的正确使用策略

| 场景    | 建议           |
| ----- | ------------ |
| DB ID | string       |
| 前后端传输 | string       |
| 内部计算  | BigInt（隔离使用） |
| 日志/埋点 | 显式转换         |

---

### 4️⃣ 经验结论

> **BigInt 是“内部工具”，不是“接口数据类型”**

---

## 五、这些坑为什么在 Node 特别致命？

因为 Node：

* 单进程
* 高并发
* 状态共享风险极高

👉 **一次写错 = 全局放大**

---

## 六、Node 服务端“语言级安全清单”（可直接贴规范）

### ❌ 禁止清单

* 模块级存请求数据
* 浅拷贝配置对象后修改
* 浮点数算钱
* BigInt 直接进 JSON
* 对象存在循环引用还序列化

---

### ✅ 推荐清单

* 配置对象 freeze
* 请求态显式创建
* 金额统一整数
* BigInt 只在边界内使用
* 所有输出对象可序列化

---

## 七、一句话总结（非常适合写在章节结尾）

> **Node.js 的坑，不在并发模型，而在语言细节被并发放大**

---
