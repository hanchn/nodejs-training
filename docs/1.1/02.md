# Promise / async-await 的本质

## ——不是“更简单的回调”，而是**调度机制**

> **Promise 不是异步本身**
> **async-await 也不会开线程**
> 它们做的只有一件事：
> 👉 **把“未来要执行的代码”交给事件循环安排**

---

## 一、先给结论（非常重要）

### 三个必须刻在脑子里的结论

1️⃣ **Promise 的回调一定进 microtask 队列**
2️⃣ **async-await 本质 = Promise + then**
3️⃣ **await 不会阻塞线程，只会“切函数执行权”**

---

## 二、Promise 到底是什么？

### 1️⃣ Promise 的真实定义（工程版）

> Promise 是一个**状态机 + 回调注册器**

状态：

* pending
* fulfilled
* rejected

能力：

* 注册 then / catch / finally
* **在未来某个时间点统一触发**

---

### 2️⃣ Promise ≠ 异步

```js
new Promise(resolve => {
  resolve(1)
})
console.log('end')
```

输出顺序：

```text
end
```

👉 Promise **不是异步执行器**
👉 then 才是

---

### 3️⃣ then 的本质：microtask 注册

```js
Promise.resolve().then(() => {
  console.log('then')
})
```

这一步等价于：

```text
把回调塞进 microtask 队列
```

---

## 三、async / await 的真正等价写法

### 1️⃣ async 函数 = 返回 Promise 的函数

```js
async function foo() {
  return 1
}
```

等价于：

```js
function foo() {
  return Promise.resolve(1)
}
```

---

### 2️⃣ await 的真实展开（重点）

```js
async function foo() {
  const res = await fetchData()
  console.log(res)
}
```

**等价于：**

```js
function foo() {
  return fetchData().then(res => {
    console.log(res)
  })
}
```

> ❗ await 只是 **语法糖**
> ❗ 没有任何“暂停线程”的能力

---

### 3️⃣ await 到底“暂停”了什么？

**不是线程，而是：**

* 当前函数的**执行上下文**
* 剩余代码被拆成一个 then 回调

---

## 四、Node.js 中的执行顺序（你一定会被问）

### 经典面试 / 线上定位题

```js
console.log(1)

async function foo() {
  console.log(2)
  await Promise.resolve()
  console.log(3)
}

foo()

Promise.resolve().then(() => console.log(4))

console.log(5)
```

### 执行顺序解析

同步阶段：

```text
1
2
5
```

microtask 队列：

```text
3
4
```

最终输出：

```text
1
2
5
3
4
```

---

### 关键认知点

* `await Promise.resolve()` **一定让出执行权**
* await 后的代码 → microtask
* then 顺序 ≠ 代码顺序

---

## 五、Node.js 里 async/await 的真实风险点

### ❌ 1. await 写在循环里（性能杀手）

```js
for (const id of ids) {
  await fetchUser(id) // ❌ 串行 IO
}
```

👉 IO 被**人为串行化**

**正确方式：**

```js
await Promise.all(ids.map(fetchUser))
```

---

### ❌ 2. await 不能包住同步阻塞

```js
await JSON.parse(hugeString) // ❌ 仍然阻塞
```

> await **对 CPU 阻塞无效**

---

### ❌ 3. 无意识制造“微任务风暴”

```js
while (true) {
  await Promise.resolve()
}
```

👉 event loop **永远出不了 microtask 队列**

---

## 六、Promise.all / race / allSettled 的本质区别

### 1️⃣ Promise.all

* 并发执行
* 有一个 reject → 立刻 reject
* 适合：**强依赖的并行任务**

---

### 2️⃣ Promise.allSettled

* 等全部结束
* 不关心失败
* 适合：**打点 / 兜底 / 附加能力**

---

### 3️⃣ Promise.race

* 谁先完成用谁
* 常用于：

  * 超时控制
  * 备用服务

```js
Promise.race([
  fetchAPI(),
  timeout(300)
])
```

---

## 七、Node 服务端的“异步黄金原则”

### ✅ 必须遵守的 6 条

1️⃣ **不要在 Node 里用 await 写业务串行逻辑**
2️⃣ **IO 并发优先 Promise.all**
3️⃣ **CPU 密集逻辑不要 await 包装**
4️⃣ **所有 await 都要有超时概念**
5️⃣ **await 后的代码 = 异步回调**
6️⃣ **错误一定 try/catch 包住 await**

---

## 八、一句话总结（可写在教程封面）

> **Promise 决定“什么时候执行”**
> **async-await 决定“怎么写得像同步”**
> **真正决定性能的，从来不是 await，而是你让不让出执行权**

---

