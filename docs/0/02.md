# Node.js 适合做什么、不适合做什么

## ——从 IO 密集 vs CPU 密集说清楚本质

---

## 一句话结论（先记住这个）

> **Node.js 天生适合 IO 密集型业务，不适合纯 CPU 密集型计算。**
> 如果你用 Node 去“算”，它会拖死所有请求；
> 如果你用 Node 去“等 IO”，它能把资源榨到极致。

---

## 一、Node.js 的本质：不是“快”，而是“不等”

### 1️⃣ Node.js 的核心模型

* **单主线程 + 事件循环**
* 所有 IO 操作（网络、磁盘、数据库）**非阻塞**
* CPU 只在「真正执行 JS」时被占用

这意味着：

* ❌ 没有“每个请求一个线程”
* ✅ 一个线程服务成百上千个并发请求

---

### 2️⃣ 什么叫 IO 密集？什么叫 CPU 密集？

| 类型         | 本质          | 举例                       |
| ---------- | ----------- | ------------------------ |
| **IO 密集**  | 大部分时间在等外部资源 | HTTP 请求、DB 查询、Redis、文件读写 |
| **CPU 密集** | 大部分时间在算     | 图片压缩、视频转码、复杂加密、数据分析      |

Node.js 的优势在于：

> **“等 IO 的时候，我不闲着，我去服务别人”**

---

## 二、Node.js 为什么适合 IO 密集型？

### 1️⃣ 非阻塞 IO + 事件驱动

```text
请求 A → 发起 DB 查询 → 立刻返回事件循环
请求 B → 发起 HTTP 请求 → 立刻返回事件循环
请求 C → 渲染模板
……
DB 返回 → 回调/Promise 执行
```

👉 **同一时间，Node 在“等很多事”，但从不“卡住”**

---

### 2️⃣ 极少的线程切换成本

对比传统多线程模型：

| 模型             | 问题         |
| -------------- | ---------- |
| Java / PHP-FPM | 线程多、上下文切换重 |
| Node.js        | 单线程、几乎无切换  |

在**高并发 + 轻逻辑**场景下：

* Node 的 QPS / 机器性价比非常高
* CPU 利用率极其“平滑”

---

## 三、Node.js 最擅长的业务场景（强推荐）

### ✅ 1. Web API / BFF / 网关层

**典型特征**

* 聚合多个后端接口
* 逻辑轻、请求多
* 强依赖 IO

**为什么 Node 合适**

* 等接口时间远大于计算时间
* Promise/async 写聚合逻辑极其自然

---

### ✅ 2. SSR / 模板渲染（轻渲染）

**前提很重要：**

* 模板逻辑简单
* 不做复杂计算
* 控制渲染时间

**适合**

* EJS / Handlebars / Nunjucks
* 首页、列表页、SEO 页面

**不适合**

* 大量数据循环
* 复杂格式化、排序、统计

---

### ✅ 3. 实时系统 & 长连接

* WebSocket
* SSE
* IM / 实时通知
* 日志/埋点上报

**原因**

* 本质是大量 socket IO
* Node 的事件模型非常契合

---

### ✅ 4. 中间层、胶水层、自动化任务

* MQ 消费
* 定时任务（非重计算）
* 文件转发、Webhook 回调
* 调度系统

---

### ✅ 5. 高并发但“逻辑很轻”的场景

> 1000 并发，每个请求只干 5ms 的事
> → Node 表现极好

---

## 四、Node.js 明确不适合的场景（踩坑重灾区）

### ❌ 1. 纯 CPU 密集型计算

比如：

* 图片/视频转码
* 大规模加解密
* 数据科学、统计分析
* 大 JSON 复杂遍历 + 计算

**原因很简单：**

> CPU 一旦被占用，事件循环就停了
> → 所有请求一起“陪葬”

---

### ❌ 2. 同步阻塞代码（哪怕很短）

```js
// ❌ 一次就能拖慢所有请求
for (let i = 0; i < 1e9; i++) {}
```

```js
// ❌ 同步 fs
fs.readFileSync('big.json')
```

哪怕只阻塞 **50ms**：

* 在高并发下也会被无限放大

---

### ❌ 3. 重计算 + 高并发混在一个进程

这是线上事故高发区：

```text
同一个 Node 服务
├── SSR 页面请求
├── API 聚合
└── 图片处理 / 复杂计算
```

👉 **一个请求算慢了，所有请求都慢**

---

## 五、工程上的“正确姿势”（非常关键）

### ✅ 1. Node 只做它擅长的事

* IO 编排
* 轻逻辑
* 聚合
* 控制流

**计算交给谁？**

* C++ 扩展
* Worker Threads
* 独立计算服务（Go / Java / Rust）

---

### ✅ 2. CPU 密集任务的解法

#### 方案一：Worker Threads

```text
Node 主线程
  ├── 接请求
  └── 把计算丢给 Worker
```

适合：

* 小规模 CPU 计算
* 不想拆服务

---

#### 方案二：服务拆分（强烈推荐）

```text
Node（IO）
  ↓
计算服务（CPU）
```

* Node 永远不被拖慢
* 计算服务可独立扩容

---

### ✅ 3. 必须做到的底线原则

| 原则           | 解释               |
| ------------ | ---------------- |
| 不写同步阻塞代码     | 尤其是 fs / crypto  |
| 控制单请求 CPU 时间 | SSR/模板要警惕        |
| 拆分 IO 与计算职责  | 架构层面解决           |
| 用监控盯事件循环     | event loop delay |

---

## 六、一个非常实用的判断公式

> **如果一个请求：**

* 80% 时间在等外部资源
* 20% 时间在 JS 里跑逻辑

👉 **Node 非常适合**

---

> **如果一个请求：**

* 80% 时间在 JS 里算
* 20% 时间在等 IO

👉 **Node 一定会出问题**

---

## 七、总结一句“架构级结论”

> **Node.js 不是性能差，而是“职责边界极其明确”**
> 用它做 IO 编排，你会觉得它很强
> 用它做计算，你会觉得它“莫名其妙就卡死”

