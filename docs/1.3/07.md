## fs · path · os · crypto · stream · child_process · worker_threads

> **Node 内置模块 = 操作系统能力的“受控入口”**
> 用对了是性能利器，用错了是线上事故源头。

---

## 一、先给总览（建立正确的使用边界）

```text
┌─────────────── Node 进程 ───────────────┐
│ fs            → 文件系统（IO）           │
│ path          → 路径计算（纯工具）       │
│ os            → 系统信息（只读）         │
│ crypto        → 加密/摘要（CPU/IO混合）  │
│ stream        → 高性能 IO 管道           │
│ child_process → 新进程（系统级隔离）    │
│ worker_threads→ 同进程多线程（CPU）     │
└─────────────────────────────────────────┘
```

**核心原则一句话：**

> **fs / crypto / stream = IO 能力**
> **worker_threads / child_process = CPU 隔离手段**

---

## 二、fs：文件系统（最容易拖垮 Node）

### 1️⃣ fs 的真实分类（非常重要）

| 类型      | API                   | 特点       |
| ------- | --------------------- | -------- |
| 同步      | `fs.readFileSync`     | ❌ 阻塞事件循环 |
| 异步回调    | `fs.readFile`         | ⚠️ 老写法   |
| Promise | `fs.promises`         | ✅ 推荐     |
| Stream  | `fs.createReadStream` | ✅ 大文件必选  |

---

### 2️⃣ Node 服务端 fs 铁律

❌ **线上服务禁止：**

```js
fs.readFileSync()
fs.writeFileSync()
```

哪怕：

* 文件很小
* 调用频率不高

👉 **同步 fs = 全进程阻塞**

---

### 3️⃣ 正确姿势（生产级）

```js
import { readFile } from 'fs/promises'

const data = await readFile(filePath)
```

或（大文件）：

```js
fs.createReadStream(file).pipe(res)
```

---

## 三、path：路径计算（安全模块）

### 1️⃣ path 是纯工具模块

* 不 IO
* 不状态
* 不阻塞

👉 **几乎 0 风险**

---

### 2️⃣ 服务端必须用 path 的原因

❌ 错误写法：

```js
const file = __dirname + '/' + req.query.name
```

✅ 正确写法：

```js
const file = path.join(__dirname, req.query.name)
```

👉 防止：

* 路径穿越
* 跨平台问题

---

## 四、os：系统信息（只读，不做决策）

### 1️⃣ os 能拿到什么？

* CPU 核心数
* 内存大小
* 系统类型

```js
os.cpus().length
os.totalmem()
```

---

### 2️⃣ 工程级建议

| 用途      | 是否推荐 |
| ------- | ---- |
| 监控 / 打点 | ✅    |
| 日志上报    | ✅    |
| 动态调度逻辑  | ❌    |

👉 **不要根据 os 信息做“运行时策略切换”**

---

## 五、crypto：加密模块（CPU + libuv 线程池）

### 1️⃣ crypto 的本质

* 部分算法：走 libuv 线程池
* 部分算法：直接占 CPU

```js
crypto.pbkdf2()
crypto.createHash()
```

---

### 2️⃣ 服务端大坑

#### ❌ 高并发密码学计算

```js
await bcrypt.hash(password)
```

👉 libuv 线程池被打满
👉 fs / dns / crypto 全部排队

---

### 3️⃣ 正确策略

| 场景   | 建议             |
| ---- | -------------- |
| 登录注册 | 限流             |
| 批量计算 | worker_threads |
| 重加密  | 独立服务           |

---

## 六、stream：Node 的“性能王牌”

![Image](https://miro.medium.com/0%2AQrDkO_qFHlojbXUu.png)

![Image](https://miro.medium.com/v2/resize%3Afit%3A1400/1%2ANPkRYlAIZIkU5kNrg70SOg.png)

![Image](https://pawelgrzybek.com/understanding-nodejs-streams/2020-07-14-1.png)

### 1️⃣ stream 解决什么问题？

> **不把数据一次性读进内存**

---

### 2️⃣ 四种 stream（必须知道）

| 类型        | 作用 |
| --------- | -- |
| Readable  | 读  |
| Writable  | 写  |
| Duplex    | 读写 |
| Transform | 变换 |

---

### 3️⃣ Node 服务端典型正确用法

```js
fs.createReadStream(file)
  .pipe(zlib.createGzip())
  .pipe(res)
```

优点：

* 自动背压
* 内存稳定
* 可组合

👉 **大文件 / 日志 / 网络 IO 必用**

---

## 七、child_process：系统级隔离（重锤）

### 1️⃣ child_process 是什么？

> **直接起一个新进程**

```js
spawn('node', ['task.js'])
```

---

### 2️⃣ 适合场景

| 场景      | 推荐 |
| ------- | -- |
| 图片/视频处理 | ✅  |
| 调用外部程序  | ✅  |
| 不可信代码   | ✅  |

---

### 3️⃣ 代价

* 进程创建慢
* IPC 成本高
* 运维复杂

👉 **不是高频工具**

---

## 八、worker_threads：Node 的“CPU 解法”

### 1️⃣ worker_threads 是什么？

> **同一进程内的多线程 JS 执行**

```js
new Worker('./worker.js')
```

---

### 2️⃣ 什么时候用它？

| 场景      | 是否合适 |
| ------- | ---- |
| 图片压缩    | ✅    |
| 加密计算    | ✅    |
| SSR 重渲染 | ⚠️   |
| IO 任务   | ❌    |

---

### 3️⃣ 工程级结论

| 对比   | worker_threads | child_process |
| ---- | -------------- | ------------- |
| 内存   | 共享             | 独立            |
| 创建成本 | 低              | 高             |
| 隔离性  | 中              | 高             |
| 适合   | CPU 任务         | 系统级任务         |

---

## 九、Node 服务端“模块使用红线表”

| 模块             | 禁止       | 推荐                |
| -------------- | -------- | ----------------- |
| fs             | sync API | promises / stream |
| path           | 手写路径     | join / resolve    |
| os             | 业务决策     | 监控                |
| crypto         | 无限制调用    | 限流 / worker       |
| stream         | 忽略错误     | pipeline          |
| child_process  | 高频调用     | 任务型               |
| worker_threads | IO 任务    | CPU 任务            |

---

## 十、一句话总结（非常适合写在章节结尾）

> **fs 决定你会不会阻塞
> crypto 决定你会不会打满线程池
> stream 决定你会不会炸内存
> worker / child_process 决定你能不能把 CPU 从 Node 身上拿走**

