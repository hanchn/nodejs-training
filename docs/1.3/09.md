## net · dns · tls · http / https / http2

![Image](https://i.sstatic.net/WtFou.png)

![Image](https://static-assets.codecademy.com/Courses/Learn-Node/http/tcp-udp.png)

![Image](https://cdn.prod.website-files.com/5ff66329429d880392f6cba2/676d4500b15423be50fc505f_6149cbd7fd4bdd7c82f55cc6_http1%2520vs%2520http2.png)

```text
应用层：   http / https / http2
安全层：   tls
传输层：   tcp
系统层：   net / dns
```

一句话先立住：

> **net 决定“连不连得上”
> dns 决定“找不找得到”
> tls 决定“安不安全”
> http 决定“怎么说话”**

---

## 一、net：最底层的 TCP 能力（一切网络的起点）

### 1️⃣ net 是什么？

`net` 是 Node 对 **TCP / IPC** 的直接封装：

```js
import net from 'net'

const server = net.createServer(socket => {
  socket.on('data', data => {})
})
```

👉 没有：

* HTTP
* Header
* Request / Response

只有：

* **字节流**

---

### 2️⃣ net 在工程里的真实用途

| 场景      | 是否推荐 |
| ------- | ---- |
| 自定义协议   | ✅    |
| 高性能内部通信 | ✅    |
| Web 服务  | ❌    |
| 业务 API  | ❌    |

---

### 3️⃣ net 的重要工程认知

* TCP 是 **长连接**
* Node 不会帮你分包 / 粘包
* 所有协议都建立在 net 之上

> **http ≈ 在 net 之上加了一套“规则”**

---

## 二、dns：最容易被忽略的“性能瓶颈”

### 1️⃣ dns 在 Node 中做什么？

```js
import dns from 'dns'
dns.lookup('example.com')
```

👉 把域名解析成 IP

---

### 2️⃣ Node 的 dns 有两种模式（非常重要）

#### ✅ 1. `dns.lookup`（默认）

* 走系统 resolver
* 可能阻塞 libuv 线程池
* **受 OS 缓存影响**

#### ⚠️ 2. `dns.resolve`

* 直接发 DNS 请求
* 不走系统缓存
* 结果更“真实”

---

### 3️⃣ 线上常见问题

| 问题       | 本质                |
| -------- | ----------------- |
| 偶发慢请求    | DNS 解析慢           |
| 高并发卡顿    | libuv 线程池被 DNS 占满 |
| 不同机器结果不同 | OS 缓存差异           |

---

### 4️⃣ 工程级建议

* 高频请求 **不要频繁 DNS**
* 长连接 + Keep-Alive
* DNS 问题优先在 **系统 / 容器层** 解决

---

## 三、tls：HTTPS 的安全基石（也是性能成本）

### 1️⃣ tls 是什么？

> **TLS = 在 TCP 之上建立的加密通道**

```text
TCP 连接
↓
TLS 握手
↓
加密通信
```

---

### 2️⃣ TLS 握手在干什么？

* 证书校验
* 密钥协商
* 加密算法确认

👉 **这是一个 CPU + 网络都很重的过程**

---

### 3️⃣ Node 中 tls 的工程影响

| 场景   | 影响     |
| ---- | ------ |
| 新建连接 | 非常慢    |
| 没有复用 | CPU 飙升 |
| 大促   | 成本放大   |

---

### 4️⃣ 工程结论（非常重要）

> **HTTPS 慢，不是 Node 慢，是 TLS 慢**

必须配合：

* Keep-Alive
* HTTP/2
* CDN / Edge

---

## 四、http / https：Node 最常用但最容易误解的模块

### 1️⃣ http 本质是什么？

> **http = TCP 上的“文本协议”**

Node 的 `http.createServer`：

* 本质是 **net + parser**
* 每个请求仍然跑在事件循环里

---

### 2️⃣ https ≠ http + s

```js
https.createServer({ cert, key })
```

* https = http + tls
* 多了：

  * 握手
  * 加解密
  * 证书校验

👉 **性能模型完全不同**

---

### 3️⃣ Node http 的关键特性

| 特性         | 说明        |
| ---------- | --------- |
| Keep-Alive | 默认开启（客户端） |
| Header 解析  | JS 参与     |
| Body 流     | Stream    |
| 并发         | 单进程       |

---

## 五、http2：真正为“高并发”设计的协议

![Image](https://cdn.prod.website-files.com/5ff66329429d880392f6cba2/676d4500b15423be50fc505f_6149cbd7fd4bdd7c82f55cc6_http1%2520vs%2520http2.png)

![Image](https://blog.vespa.ai/assets/2021-07-01-http2/http2-multiplexing.png)

### 1️⃣ HTTP/1.1 的核心问题

* 一个连接一次只能处理一个请求
* 队头阻塞（HOL）

---

### 2️⃣ HTTP/2 解决了什么？

| 能力        | 价值        |
| --------- | --------- |
| 多路复用      | 一个连接并发多请求 |
| Header 压缩 | 减少体积      |
| 二进制协议     | 解析更快      |

---

### 3️⃣ Node 使用 http2 的真实情况

```js
import http2 from 'http2'
```

⚠️ 工程现实：

* 浏览器支持好
* Node 服务端调试成本高
* 中间件生态弱

👉 **生产中通常由 CDN / LB 承担**

---

## 六、一次完整 HTTPS 请求的 Node 视角

```text
1. DNS：域名 → IP
2. net：建立 TCP 连接
3. tls：TLS 握手
4. http：解析请求
5. JS：业务逻辑
6. http：写响应
7. tls：加密
8. net：发送数据
```

👉 **JS 真正执行的时间，通常不到 10%**

---

## 七、Node 网络栈的“性能责任划分”

| 层       | 谁负责           |
| ------- | ------------- |
| DNS     | OS / 容器 / 云厂商 |
| TLS     | CDN / LB      |
| HTTP 协议 | 框架            |
| 业务逻辑    | Node          |

> **Node 的强项是第 4 层之后**

---

## 八、工程级红线与最佳实践

### ❌ 常见错误

* 每个请求都新建连接
* 忽略 DNS 延迟
* Node 直扛 TLS 大流量
* 在 http handler 里做重计算

---

### ✅ 正确姿势

* Keep-Alive + 连接复用
* CDN / Edge 终止 TLS
* Node 专注 IO 编排
* http body 用 stream

---

## 九、一句话总结（可写进教程）

> **net 是地基
> dns 是导航
> tls 是保险
> http 是语言
> http2 是效率**

---
