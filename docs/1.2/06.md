# 全局对象与运行上下文

## global · process · Buffer · URL

> **Node.js 不是“随便跑 JS 的地方”**
> 它有一套非常明确的**运行时上下文边界**
> ——理解这四个对象，才能写出**不串请求、不泄漏、不炸内存**的服务

---

## 一、先给总览（一定要先立这个模型）

```text
一个 Node 进程
│
├── global      → 全局命名空间（共享）
├── process     → 进程状态与生命周期
├── Buffer      → 二进制内存视图
└── URL         → 标准化地址与参数解析
```

> **核心原则：**
>
> * global / process = ❗跨请求共享
> * Buffer / URL = ✅请求级 / 数据级工具

---

## 二、global：Node 的“全局共享空间”（高危）

### 1️⃣ global 是什么？

```js
global.foo = 1
```

* Node 进程级全局对象
* 所有模块、所有请求共享
* 类似浏览器的 `window`，但**危险得多**

---

### 2️⃣ Node 中 global 的真实风险

#### ❌ 典型事故代码

```js
global.currentUser = null

app.use((req, res, next) => {
  global.currentUser = req.user
  next()
})
```

👉 **并发请求必然串数据**

---

### 3️⃣ 正确使用 global 的唯一场景

| 允许       | 禁止     |
| -------- | ------ |
| 常量       | 请求态数据  |
| 只读配置     | 用户信息   |
| 打点工具     | 缓存请求对象 |
| polyfill | 状态写入   |

📌 **99% 的业务代码不应该碰 global**

---

## 三、process：Node 的“进程控制面板”

### 1️⃣ process 是什么？

```js
process.pid
process.env
process.argv
process.uptime()
```

* 描述 **当前 Node 进程**
* 不是“当前请求”
* 所有请求共享

---

### 2️⃣ process.env（最常用，也最容易误用）

```js
const env = process.env.NODE_ENV
```

#### ⚠️ 关键认知

* 全部是 **string**
* 修改会影响整个进程

```js
process.env.DEBUG = '1' // ❌ 运行时修改配置
```

👉 **这是全局副作用**

---

### 3️⃣ process 的正确用途

| 场景    | 是否合理 |
| ----- | ---- |
| 读环境变量 | ✅    |
| 进程级配置 | ✅    |
| 启停监听  | ✅    |
| 存请求数据 | ❌    |

---

### 4️⃣ 服务端必会的 process 能力

```js
process.on('uncaughtException')
process.on('unhandledRejection')
process.on('SIGTERM')
```

👉 用于：

* 优雅退出
* 容器 / K8s 生命周期
* 崩溃兜底（记录，不是继续跑）

---

## 四、Buffer：Node 的“真实内存操作层”

### 1️⃣ Buffer 是什么？

> **Buffer 是 Node 对二进制内存的直接抽象**

```js
const buf = Buffer.from('hello')
```

* 不在 V8 堆上（早期）
* 直接映射底层内存
* 性能极高，也极危险

---

### 2️⃣ Buffer 在 Node 中的真实用途

| 场景     | 是否推荐 |
| ------ | ---- |
| 文件读写   | ✅    |
| 网络数据   | ✅    |
| 编码转换   | ✅    |
| 普通业务对象 | ❌    |

---

### 3️⃣ Buffer 的几个服务端大坑

#### ❌ 1. Buffer 太大

```js
Buffer.alloc(100 * 1024 * 1024)
```

👉 **内存瞬间暴涨**

---

#### ❌ 2. Buffer 泄漏

```js
global.cache = Buffer.from(bigFile)
```

👉 **GC 管不了你**

---

### 4️⃣ 工程结论

> **Buffer 是“刀”，不是“容器”**
> 用来切数据，不用来存数据

---

## 五、URL：被严重低估的“安全工具”

### 1️⃣ URL 在 Node 中是什么？

```js
const u = new URL('https://a.com?a=1')
```

* WHATWG 标准
* 与浏览器一致
* 比 string 处理**安全得多**

---

### 2️⃣ URL 能帮你避免什么？

#### ❌ 手写解析

```js
req.url.split('?')
```

#### ✅ 标准解析

```js
const url = new URL(req.url, 'http://localhost')
```

避免：

* 编码错误
* 注入
* 边界 case

---

### 3️⃣ Node 服务端的推荐用法

| 场景       | 推荐                    |
| -------- | --------------------- |
| query 解析 | URL / URLSearchParams |
| 路由判断     | URL.pathname          |
| 参数拼接     | url.searchParams      |
| 重定向      | URL.toString          |

---

## 六、运行上下文的“安全分层模型”（非常重要）

```text
进程级（危险）
├── global
├── process
│
请求级（安全）
├── req / res
├── URL
├── Buffer（短生命周期）
```

👉 **凡是跨请求共享的对象，一定要极度克制**

---

## 七、Node 服务端的铁律总结（可贴规范）

### ❌ 永远不要

* 在 global / process 存请求态数据
* 把 Buffer 放进全局缓存
* 用字符串手写 URL 解析
* 运行时修改 process.env

---

### ✅ 推荐做法

* global 只放只读常量
* process 只用于进程控制
* Buffer 即用即弃
* URL 做一切地址处理

---

## 八、一句话“架构级总结”

> **global 决定你会不会串请求
> process 决定你能不能安全退出
> Buffer 决定你会不会炸内存
> URL 决定你写的代码安不安全**

---

